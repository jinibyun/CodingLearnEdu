/* ---------------- Answer to Assignment -------------------*/

========================
Assignment 1
========================
create view production.vwGetBrand_AvgPrice
as 
SELECT
    brand_name,
    AVG (list_price) avg_price
FROM
    production.products p
INNER JOIN production.brands b ON b.brand_id = p.brand_id
WHERE
    model_year = 2018
GROUP BY
    brand_name

-- test
select * from production.vwGetBrand_AvgPrice


=========================
Assignment 2
=========================
create proc usp_GetSalesAmountByYearAndName
@year int, @name varchar(100)
as
begin
    WITH cte_sales_amounts (staff, sales, year) AS (
        SELECT    -- it is like "subquery"
            first_name + ' ' + last_name, 
            SUM(quantity * list_price * (1 - discount)),
            YEAR(order_date)
        FROM    
            sales.orders o
        INNER JOIN sales.order_items i ON i.order_id = o.order_id
        INNER JOIN sales.staffs s ON s.staff_id = o.staff_id
        GROUP BY 
            first_name + ' ' + last_name,
            year(order_date)
    )

    SELECT
        staff, 
        sales
    FROM 
        cte_sales_amounts
    WHERE
        year = @year and staff like '%' + @name + '%'
end

-- test
exec usp_GetSalesAmountByYearAndName 2018, 'genna'


=========================
Assignment 3
=========================
create proc usp_updateCommissions
@staff_Id int,
@howmuch DECIMAL(10, 2) OUTPUT
as
begin
    BEGIN TRY
        BEGIN TRANSACTION;
        
        UPDATE
            sales.commissions
        SET
            sales.commissions.commission = 
                c.base_amount * t.percentage
        FROM 
            sales.commissions c
            INNER JOIN sales.targets t
                ON c.target_id = t.target_id
                AND c.staff_id=@staff_Id
        
        select @howmuch = commission from sales.commissions where staff_id=@staff_Id

        COMMIT TRANSACTION;  
    END TRY
    BEGIN CATCH
        ROLLBACK TRANSACTION;

        SELECT   
            ERROR_NUMBER() AS ErrorNumber  
            ,ERROR_SEVERITY() AS ErrorSeverity  
            ,ERROR_STATE() AS ErrorState  
            ,ERROR_LINE () AS ErrorLine  
            ,ERROR_PROCEDURE() AS ErrorProcedure  
            ,ERROR_MESSAGE() AS ErrorMessage;  
    END CATCH
end; -- end of sp

--test
declare @howmuch decimal(10,2)
exec usp_updateCommissions 1, @howmuch OUTPUT
select @howmuch

-- test of table
select * from sales.commissions


=========================
Assignment 4
=========================
create function production.fnGetBrand_AvgPrice(@model_year int)
RETURNS TABLE
AS
RETURN
    SELECT
        brand_name,
        AVG (list_price) avg_price
    FROM
        production.products p
    INNER JOIN production.brands b ON b.brand_id = p.brand_id
    WHERE
        model_year = @model_year
    GROUP BY
        brand_name

-- test
select * from production.fnGetBrand_AvgPrice(2017)




=========================
Assignment 5
=========================
CREATE FUNCTION sales.udfNotCompleted(
    @year INT
)
RETURNS int
AS 
BEGIN
    declare @notcompletedCount int

    SELECT    
        @notcompletedCount= COUNT(*)
    FROM    
        sales.orders
    WHERE 
        YEAR(order_date) = @year and order_status <> 4

    return @notcompletedCount
END;

-- test
select sales.udfNotCompleted(2017);

=========================
Assignment 6
=========================
별도의 답안이 있는게 아니라, 기존의 코드를 이해/분석하게 하고 간단하게 나마 if ... else ...의 경우의 매치되는 다이어 그램을 그리도록 한다


=========================
Assignment 7
=========================

DECLARE @Id INT ,  
@RollNo INT,  
@Branch NVARCHAR(50) ,  
@Year AS INT  
   
SET @Year = RIGHT(YEAR(GETDATE()), 2)  
   
DECLARE MY_data CURSOR  
FOR  
    SELECT  Id ,  
            Branch,  
            RollNo,  
            @Year  
    FROM    test.students  
   
OPEN MY_data  
FETCH NEXT FROM MY_data INTO @Id, @Branch, @RollNo,@Year  
WHILE @@FETCH_STATUS = 0  
    BEGIN  
        DECLARE @EnrollmentNo NVARCHAR(15)  
                SET @EnrollmentNo = 'IT' + CAST(@Year AS VARCHAR(2)) + CAST(@Branch AS NVARCHAR(50)) + '000' + CAST(@RollNo AS NVARCHAR(10))  
                  
                UPDATE test.students SET EnrollmentNo =  @EnrollmentNo WHERE Id =  @Id  
   
        FETCH NEXT FROM MY_data INTO  @Id, @Branch, @RollNo,@Year  
    END  
CLOSE MY_data  
DEALLOCATE MY_data  

-- test
select * from test.students


=================================
Assignment 8 
=================================

CREATE INDEX idx_IndexTest_num
ON IndexTest(num)
INCLUDE (name, updateDate);

-- test
-- estimate execute plan 을 통해 확인 한다.


================================
Assignment 9
================================
-- 분석해서 주석 단 결과
CREATE PROCEDURE SaveTranExample  
    @model_year INT  
AS  
    DECLARE @TranCounter INT;  
    SET @TranCounter = @@TRANCOUNT;  // 현재 활성화 되어 있는 transaction 이 있는 지 체크. 즉 이 SP 를 실행하기 전에 어떤 트랜잭션이 있다는 의미이다.

    IF @TranCounter > 0         
        SAVE TRANSACTION ProcedureSave;  // 이 시점 부터 rollback (partial rollback 을 하게 하기 위해)
    ELSE    
        BEGIN TRANSACTION;  // 새로운 트랜잭션 시작

    -- 실질적인 변경 작업  
    BEGIN TRY  
        DELETE FROM 
            production.product_history
        WHERE
            model_year = @model_year; 
        
        IF @TranCounter = 0  // 활성화 된 (앞서서) 트랜잭션이 없을 때에만 위의 구문 실행
            COMMIT TRANSACTION;  
    END TRY  
    BEGIN CATCH  
        -- 에러가 발생했다면 rollback 를 해줘야 한다.  
        -- 주의: 이 프로시저가 아닌 다른 프로시저에서 활성화 된 트랜잭션에 대해서는 rollback 할 수 없다.
        IF @TranCounter = 0  
            ROLLBACK TRANSACTION;  
        ELSE  
            IF XACT_STATE() <> -1   
                ROLLBACK TRANSACTION ProcedureSave;  
  
        -- 에러 메시지 출력 
        DECLARE @ErrorMessage NVARCHAR(4000);  
        DECLARE @ErrorSeverity INT;  
        DECLARE @ErrorState INT;  
  
        SELECT @ErrorMessage = ERROR_MESSAGE();  
        SELECT @ErrorSeverity = ERROR_SEVERITY();  
        SELECT @ErrorState = ERROR_STATE();  
  
        RAISERROR (@ErrorMessage, -- Message text.  
                   @ErrorSeverity, -- Severity.  
                   @ErrorState -- State.  
                   );  
    END CATCH  
GO


================================
Assignment 10
================================
-- 본문의 예제를 보고 바로 참고해서 작성한다.



================================
Assignment 11
================================
create proc usp_genResultFromXML
as
begin

  DECLARE @XML AS XML, @hDoc AS INT

  SELECT @XML = CONVERT(XML, BulkColumn)
  FROM OPENROWSET(BULK 'C:\customerOrder.xml', SINGLE_BLOB) AS x

  --중간 확인
  

  EXEC sp_xml_preparedocument @hdoc OUTPUT, @XML

      SELECT CustomerID, CustomerName, Address, OrderID, OrderDate
      FROM OPENXML(@hDoc, 'ROOT/Customers/Customer/Orders/Order')
      WITH 
      (
        CustomerID [varchar](50) '../../@CustomerID',
        CustomerName [varchar](100) '../../@CustomerName',
        Address [varchar](100) '../../Address',
        OrderID [varchar](1000) '@OrderID',
        OrderDate datetime '@OrderDate'
      )
      
  EXEC sp_xml_removedocument @hdoc

end;


================================
Assignment 12
================================
코드 분석하기


================================
Assignment 13
================================
DECLARE @json NVARCHAR(MAX);

SET @json = N'[
  {"id": 2, "info": {"name": "John", "surname": "Smith"}, "age": 25},
  {"id": 5, "info": {"name": "Jane", "surname": "Smith"}, "dob": "2005-11-04T12:00:00"}
]';

SELECT *
FROM OPENJSON(@json) WITH (
    id INT 'strict $.id',
    firstName NVARCHAR(50) '$.info.name',
    lastName NVARCHAR(50) '$.info.surname',
    age INT,
    dateOfBirth DATETIME2 '$.dob'
    );


================================
Assignment 14
================================
create proc usp_get_call_api_jsonplaceholder_post
@userId varchar(10)
as 
begin

    BEGIN TRY
        --DECLARE @userid int = 1;
        DECLARE @URL NVARCHAR(MAX) =  'https://jsonplaceholder.typicode.com/posts?userId=';
        set @URL = CONCAT(@url, @userid);
        Declare @Object as Int;
        Declare @ResponseText as Varchar(8000);

        -- 1. 생성
        Exec sp_OACreate 'MSXML2.XMLHTTP', @Object OUT; -- 주의: @Object 의 타입은 반드시 Int

        -- 2. Call
        Exec sp_OAMethod @Object, 'open', NULL, 'get',
            @URL,
            'False'
        Exec sp_OAMethod @Object, 'send', null
        Exec sp_OAMethod @Object, 'responseText', @ResponseText OUTPUT

        --select @ResponseText

        IF((Select @ResponseText) <> '')
        BEGIN
            DECLARE @json NVARCHAR(MAX) = (Select @ResponseText)
            
            
            INSERT INTO test.Posts_details (userId, id, Post_title, Post_body)
            SELECT *
            FROM OPENJSON(@json) -- 앞서 배웠던 OPENJSON 적용
                WITH (
                        userId NVARCHAR(30) '$.userId',
                        id varchar(30) '$.id',
                        title varchar(300) '$.title',
                        body varchar(8000) '$.body'
                    );
        END
        ELSE
        BEGIN
            DECLARE @ErroMsg NVARCHAR(30) = 'No data found.';
            Print @ErroMsg;
        END

        -- 3
        Exec sp_OADestroy @Object -- (명시하지 않아도, 자동으로 생성된 내부 객체가 없어지지만, 명시적으로 적어주는 것이 일반적)
    End TRY
    Begin CATCH
        SELECT  
             ERROR_NUMBER() AS ErrorNumber  
            ,ERROR_SEVERITY() AS ErrorSeverity  
            ,ERROR_STATE() AS ErrorState  
            ,ERROR_PROCEDURE() AS ErrorProcedure  
            ,ERROR_LINE() AS ErrorLine  
            ,ERROR_MESSAGE() AS ErrorMessage;   
    End Catch
end

-- test
exec usp_get_call_api_jsonplaceholder_post '1'


==================================
Assignment 15
==================================
분석


==================================
Assignment 16
==================================

--
CREATE LOGIN gunsAndroses
WITH PASSWORD='qwerasdf!!'; 
--
create database musicDB;
--
use musicDB;
--
CREATE USER gunsAndroses
FOR LOGIN gunsAndroses;
-- 
CREATE SCHEMA music -- 스키마를 생성하면서 gunsAndroses 에게 소유권 지정
AUTHORIZATION gunsAndroses;
--
create table music.genre(id int, name varchar(20));
create table music.streaming(id int, name varchar(20));

-- gunsAndroses 로 접근해서 두 개의 table 에 대해 조회 확인

--
ALTER AUTHORIZATION 
ON SCHEMA::music 
TO dbo; -- sql 서버의 내부 기본 사용자

--
GRANT SELECT, INSERT, UPDATE, DELETE
ON music.genre TO gunsAndroses;

-- 
REVOKE INSERT, UPDATE, DELETE
ON music.genre
FROM gunsAndroses;

--
CREATE ROLE music_role;

--
GRANT SELECT, INSERT, UPDATE, DELETE
ON SCHEMA::music 
TO music_role;

--
ALTER ROLE music_role
ADD MEMBER gunsAndroses;

--
SELECT
  r.name role_name,
  r.type role_type,
  r.type_desc role_type_desc,
  m.name member_name,
  m.type member_type,
  m.type_desc member_type_desc
FROM sys.database_principals r
INNER JOIN  sys.database_role_members  rm on rm.role_principal_id = r.principal_id
INNER JOIN sys.database_principals m on m.principal_id = rm.member_principal_id
WHERE r.name ='music_role';

--
ALTER ROLE music_role
DROP MEMBER gunsAndroses;

--
DROP ROLE IF EXISTS music_role;


===============================
Assignment 17
===============================
아래와 같은 내용을 설명하면서 ERD 디자인 기능을 이용해서 작업한다.

-- 1 단계의 NF (Normal Form) 을 다음과 같은 순서로 진행한다.
  -- 1-1. 첫 번 째: duplication 을 제거 하기 위해 PK, Unique 를 적용해 본다.
  -- 1-2. 두 번 째: redundancy 를 제거 하기 위해, 테이블을 나누어 필요시 관계 설정한다. (편의상 여기서는 plain 하게만 작업했다.)
          편의상 첫 번 째/두 번 째 함께 해결
              1. Student (StudentNo, StudentName, Major)
              2. Course (CourseNo, CourseName, Grade, InstructorNo, InstructorName, InstructorLocation) 
          (반드시, PK 속성, 혹은 필요시에 Unique 속성 부여됐는 지 확인 한다.)
          
  -- 1.3  세 번 째: 테이블과 테이블의 관계가 many to many 라면 1 to many 의 관계로 바꾼다.
          관계 해결
              1. Student (StudentNo, StudentName, Major)
              2. Course (CourseNo, CourseName, Grade, InstructorNo, InstructorName, InstructorLocation) -- course 와 instructior 는 편의상 1:many
              4. StudentCourse table (StudentNo, CourseNo)
              
-- 2 단계의 NF (Normal Form) 을 다음과 같은 순서로 진행한다.
  -- 2.1 하나의 table 내에서 관계있는 칼럼들끼리 묶여 있는 지 않을 경우를 찾아 본다.
          Course (CourseNo, CourseName, Grade, InstructorNo, InstructorName, InstructorLocation) 에서 key 가 되는 CourseNo 에 각 칼럼 값과의 연관성을 생각해 본다. Grade 를 제외 하고 Instructor .. 관련 세 칼럼 값은 다른 테이블로 정의할 수 있다.

          해결:
              1. Student (StudentNo, StudentName, Major)
              2. Course (CourseNo, CourseName, Grade)
              3. CourseInstructor (CourseNo, CourseName, InstructorNo, InstructorName, InstructorLocation) -- 1: many
              4. StudentCourse table (StudentNo, CourseNo)

-- 3 단계의 NF (Normal Form) 을 다음과 같은 순서로 진행한다. (키가 아닌 칼럼들끼리의 종속성 제거)
  --3.1 2 단계 까지 진행한 상태, 즉 duplicateion, redundancy, many to many, 그리고 밀접한 관련 있는 업무들만을 묶은 집합을 table 화 한 상태라면, 각 테이블의 키가 아닌 칼럼들을 서로 비교하여 종속성이 있는 지 확인하고, 이를 수정하여 필요로 한다면 별도의 table 로 구성한다.

          해결:
              CourseIntructor 를 보게 되면 IntrouctorNo, Name 그리고 location 이라는 정보가 CourseName 이라는 Non-key column 에 종속적이 되었다.

              1. Student (StudentNo, StudentName, Major)
              2. Course (CourseNo, CourseName, Grade)
              3. CourseInstructor (CourseNo, InstructorNo, InstructorName, InstructorLocation) -- 1: many
              4. StudentCourse table (StudentNo, CourseNo)